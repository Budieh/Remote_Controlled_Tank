<<<<<<< HEAD
-> Inainte de a incepe proiectul:

   Detin o placuta STM32-F070RB de aproximativ un an. Am inceput sa programez pe placute cu microcontrollere utilizand un Arduino Uno in anul 2 de facultate din dorinta de a intra in domeniul roboticii, fiind un subiect ce ma interesa de ceva timp. Am considerat ca, in momentul acela aveam suficiente cunostinte de programare, electronica digitala si cunostinte de baza de electronica analogica si mecanica pentru a aborda acest domeniu. Arduino a fost un punct de plecare bun din prisma simplitatii oferite de acesta: mediul de programare era suficient de straight-forward, multitudinea de biblioteci pentru diferite periferice facea programarea usoara si permitea realizarea unor proiecte nu foarte complexe rapid si cu rata de succes mare, iar layoutul ( destul de limitat ) al placutei era foarte prietenos cu incepatorii care nu au mai lucrat cu cablaje pana in acel moment. Acestea fiind spuse, simplitatea adusa de utilizarea unui Arduino Uno a inceput sa-si prezinte curand limitarile: numarul limitat de perifierice interne ( USART, I2C, SPI, Timere ), layoutul limitat, microcontroller-ul ATmega328P pe 8 biti, precum si lipsa cunstintelor mele asupra unor notiuni precum intreruperile, adresarea directa la registrii, etc. m-au impins spre a incerca o alternativa mai putin prietenoasa cu incepatorii si ce oferea o putere de procesare mai mare si un layout mai generos, asa ca m-am indreptat catre un microcontroller pe 32 de biti. Dupa cateva cautari, m-am hotarat ca o varianta buna de inceput ar fi placuta STM32-F070RB. Stiam ca inceputul nu are sa fie atat de usor, asa ca am adunat documentatia pentru aceasta ( manualul de referinta, schematica, user guide-ul, etc. ) si m-am orientat asupra unor cursuri online ce aveau ca focus programarea pe placile de dezvoltare celor de la STM, insa care sa utilizeze un microcontroller diferit fata de cel prezent pe placuta mea ( ARM Cortex M0 ), deoarece nu doream sa reproduc 1:1 ceea ce se explica in cursul respectiv, si sa trec eu prin procesul de a ma orienta asupra docuemntatiei, de a cauta adresele registrelor, de a intelege functionalitatea codului meu, de a utiliza mediul de programare ( STM32CubeIDE ) si asa mai departe. Nu a fost un proces scurt, insa in 2-3 luni eram destul de familiar cu utilizarea intreruperilor / DMA-ului, puteam conecta, programa si utiliza periferice externe precum accelerometre, giroscoape, lcd-uri prin intermediul diferitor protocoale de comunicare ( I2C, SPI, UART ), utiliza timere in diferite moduri ( normal, IC, OC, PWM, Encoder ), cauta adresele registrelor si a le adresa, procese cu care eram estul de comfortabil dupa ce am avut ocazia de a lucra cu ele pe o perioada mai lunga de timp. Cand a venit vorba despre acest proiect, am stiut ca doresc sa utilizez aceasta placuta, deoarece, pe de-o parte, eram deja familiar cu ea, imi oferea suficiente resurse pentru aplicatia pe care doream sa o implementez si, pe deasupra, imi oferea ocazia de a ma concentra pe noile elemente ce doream sa le introduc in cadrul proiectului ( modulul de comunicare prin bluetooth, motoarele de curent continuu ce actioneaza senilele, encoderele rotative precum si buclele de reglare a turatiei motoarelor implementate cu ajutorul acestora, etc. ), provocari atat hardware, cat si software. In incheierea acestei sectiuni, doresc a mentiona ca am plecat la drum avand aceasta placuta si cunostinte asupra acesteia, reprezentand baza in jurul careia are sa se contruiasca tancul propriu-zis.

-> Zilele 1-3 ( bluetooth module arc ):
   
   Am decis sa incep lucrul la proiect cu partea cea mai importanta ( in opinia mea ), si anume comunicarea prin bluetooth. Ajungand la un magazin de componente electronice din apropierea mea, am intrebat daca detin module de comunicare prin bluetooth si, spre norocul meu, am gasit un unul cu un cip ce realiza conversia bluetooth-UART, cip ce lucreaza la nivelul logic
de 3.3V, ceea ce era ideal pentru mine, placuta STM32 lucrand tot la acest nivel logic, ceea ce insemna ca nu era necesara si procurarea unui traductor de nivel logic. Am achizitionat modulul si, in seara acestei zile, am incercat sa ma documentez asupra acestuia si sa-mi fac o idee despre cum ar decurge procesul de comunicare prin bluetooth. Aici am facut prima greseala, deoarece, in loc sa citesc direct ceea ce scria pe cip-ul de pe modul, am gasit o insemnare pe PCB-ul de care acesta era atasat pe care scria ZS-040 si, dupa o cautare rapida pe 
internet, am aflat ca aceste module sunt construite in jurul cip-ului HC-05, asa ca am incheiat ziua prin a ma documenta asupra acestuia si asupra instructiunilor de programare prin UART necesare pentru a-i seta parametri. 
   In cea de-a doua zi am decis sa incerc comunicarea cu modulul. Primul indicator ca ceva nu este in regula a venit de la faptul ca, in materialele pe care le-am citit, rata de transfer 
a datelor prin UART a modulului era declarata ca avand valoarea default de 38400 bauds, insa incercand sa comunic cu acesta la aceasta rata primeam in buffer-ul de intrare numai caractere garbage, ceea ce m-a condus spre a incerca mai multe rate de transfer. Incercand 9600 bauds, am reusit sa trimit comanda de test, AT\r\n si sa primesc un raspuns pozitiv, si anume OK\r\n. Am dat initial vina pe documentatie proasta a modulului, nu ar fi fost prima data cand ma loveam de asa ceva. Al doilea indicator ca ceva nu ar fi in regula a venit de la faptul ca aproape fiecare comanda in afara de cele de test si de reset pe care le trimiteam modulului intorceau raspunsul ERROR\r\n. Am incercat sa caut pe internet daca cineva a mai intampinat aceasta problema si daca cumva sintaxa mesajelor folosite de mine ar fi eronata. Aceasta ruta nu m-a condus nicaieri, asa ca am incercat sa verific daca omiteam o secventa din setupul modulului, atat software cat si hardware ( daca trebuia sa trimit o instructiune de start, daca trebuiau realizate actiuni asupra pinului de enable, etc. ). Neavand succes nici pe aceasta ruta, am hotarat ca nu ar strica sa pun lanterna pe cip-ul de pe modul pentru a verifica daca acesta este, intr-adevar, cip-ul HC-05 si, spre surprinderea mea, am gasit inscriprionat pe acesta codul CC2541. Dupa o cautare rapida, am aflat ca acest cip imparte multe similaritati cu HC-05, printre acestea sintaxa instructiunilor de test si de reset ( destul de unfortunate, considerand faptul ca acestea au functionat mi-a dat speranta ca sunt pe pista cea buna ), insa rata default de transfer prin UART era diferita ( primul indicator de eroare ), iar restul sintaxei intructiunilor era, de asemenea, diferita ( cel de-al doilea indicator de eroare ). Dupa putina documentare am reusit sa interoghez cip-ul ( cu raspunsuri pozitive de data aceasta ) si sa setez parametrii acestuia precum numele, pin-ul de acces la conexiunea bluetooth si rata de transfer prin UART la valorile dorite de mine. La finalul zilei doi, am reusit sa setez placuta ca un bridge de comunicare dintre terminal si modulul bluetooth ( mesajele trimise din terminal erau redirectionate de catre microcontroller catre modul si vice-versa ) pentru debug / setare de parametri, sa ma conectez la bluetooth si sa trimit cateva mesaje de test prin bluetooth ( utilizand o aplicatie mobila ce functioneaza asemenea unui terminal ), mesaje ce am constatat cu bucurie ca se regasesc in buffer-ul de intrare de la modulul bluetooth utilizand modul de debug al placutei STM32 oferit de mediul de dezvoltare al celor de la STM ), ceea ce mi-a oferit confidence-ul ca, in afara de cateva coincidente nefericite legate de cip-ul ce se afla pe modulul bluetooth, restul programarii a fost realizata corect iar conexiunea mergea asa cum era de asteptat. 
   In cea de-a treia zi, stiind ca, comunicarea cu terminalul si cu modulul de pe bluetooth functioneaza, am inceput sa planific modul in care aveam sa structurez mesajele ce vor fi transmise prin bluetooth. Deoarece mesajele transmise prin UART au lungime variabila, am hotarat sa implementez comunicarea astfel: voi primi cate un byte odata utilizand modul de intrerupere al perifericei UART, urmand ca in functia de callback apelata la revenirea in programul principal in urma terminarii interrupt service routine-ului aferent perifericei UART, voi reporni receptia pe UART pentru a astepta receptionarea unui alt byte de date si asa mai departe. Consider un mesaj terminat atunci cand intalnesc un caracter special, acest caracter fiind usor de ales in cazul receptiei de la terminal si de la modulul de bluetooth ( in modul de setup al acestuia ), toate mesajele terminandu-se cu LF ( caracterul '\n' ), ceea ce imi
permitea sa verific ultimul caracter pentru a determina daca mesajul primit este complet tot in cadrul functiei de callback pentru receptie. Acum, tot ce aveam de facut era sa aleg un
caracter cu care sa termin receptia de la modulul bluetooth ( in modul de comunicare prin bluetooth al acestuia ) pentru a sti ca, la intalnirea acestui caracter, am primit un mesaj complet. Cum urmatoarea periferica pe care o aveam la indemana si pe care doream sa o setez era un servomotor pentru miscarea turelei, controlat printr-un timer setat in modul PWM al carui duty cycle trebuia modificat pentru a face servo-ul sa se miste, am hotarat ca mesajul transmis prin bluetooth va reprezenta valoarea duty cycle-ului semnalului PWM si, in consecinta, am considerat fitting ca acest mesaj sa se termine cu caracterul '%'. Dupa implementarea acestei reguli ( utilizand un switch case - pentru viteza - in care verific utlimul caracter primit la receptie ) si vazand ca totul functioneaza asa cum am planuit, am hotarat ca este suficienta munca pentru aceasta zi, urmatoarele zile concentrandu-se pe actionarea servoului prin mesaje primite de la periferica bluetooth.

-> Zilele 4-5 ( servo turret arc ):

   Setarea miscarii servoului si-a prezentat problemele din prima secunda, realizand ca acesta functioneaza la nivelul logic de 5V ( impropriu zis nivelul logic, acesta primind la intrare un semnal analogic reprezentat de tensiunea medie a semnalului PWM, tensiune controlata de catre factorul de umplere al semnalului PWM ), iar eu nu am cumparat un traductor de nivel logic de la 3.3V la 5V ( daca era de la 5V la 3.3V ar fi fost usor, as fi folosit un simplu divizor de tensiune cu o rezistenta de 1k si una de 2k, dar de la tensiune mica la tensiune mare se complica treaba :))) ), fiind fericit ca modulul bluetooth lucreaza la 3.3V. Am considerat aceasta inconveniente drept un prilej de a fi creativ si, daca e sa fi ramas cu ceva de la electronica analogica si de la partea introductiva din electronica digitala este cum functioneaza un tranzistor ttl si cum sa implementez cea mai simpla schema posibila de poarta logica cu acesta, si anume poarta NOT utilizand un singur tranzistor NPN. Avand un surplus de tranzistoare NPN si rezistente de 1k si 10k, am hotarat sa implementez 2 porti not in cascada, prima avand rezistenta de pull-up conectata la 3.3V, iar cea de-a doua la 5V, pe intrarea primei porti NOT fiind aplicat semnalul PWM cu nivelul logic de 3.3V, obtinand astfel un traductor de nivel logic rudimentar. Nu mi-am facut griji ca aceasta schema ar fi prea lenta pentu transmiterea semnalului PWM, deoarece datasheet-ul servoului recomanda ca tensiunea analogica de la intrarea acestuia sa fie generata utilizand un semnal de 50 Hz ( perioada de 20 de ms ), semnal incet ce nu ar fi trebui sa fie afectat de diferite constante de timp aparute din cauza capacitatilor parazite din circuitul traductorului, de timpii de deschidere ai tranzistoarelor, etc. . Am inceput astfel testele utilizand semnalul PWM, observand bucuros ca sevo-ul raspunde la acesta. Este posibil ca in implementarea finala a proiectului sa optez pentru un traductor de nivel logic implementat utilizand tranzistoare CMOS, insa, pentru moment ( luand in considerare diferenta de consum de curent si viteza de comutare ), insa pe moment varianta mea DIY este o alternativa acceptabila. In incheierea acestei zile, desi aveam la dispozitie o 
functie de modificare a duty cycle-ului PWM-ului disponibila intr-o biblioteca pusa la dispozitie de mediul de dezvoltare a celor de la STM, am optat sa nu o folosesc pe aceasta deoarece schimbarea duty cycle-ului necesita modificarea unui singur registru ( CCR1 - counter register 1 al perifericei Timer 16 ), profitand de aceasta ocazie pentru a adauga niste viteza aplicatiei ( evitarea update-urilor inutile ale altor registrii prin utilizarea functiei, instructiuni redundante si timpul pierdut in function call ), utilizand adresarea directa la registru, ceea ce am si facut. In cadrul functiei de callback in care receptionez mesajul de la modulul bluetooth ( primit in urma comunicarii prin bluetooth cu telefonul, mesaj ce se termina cu caracterul '%' ), am prelucrat acest mesaj ( transformand sirul de caractere in valoare numerica si, aplicand regula de 3 simpla pe baza datelor din datasheet asupra corespondentei dintre factorul de umplere si distanta - in grade - parcursa de servo, am determinat o formula prin care pot mapa duty cycle-ul semnalului PWM primit prin bluetooth la distanta parcursa de servo ) si am modificat duty cycle-ul prin adresare directa la registru. Rezultatele nu au fost in tocmai satisfacatoare, servo-ul miscandu-se numai intr-un interval de 90 de grade in locul celui de 180 de grade mentionat de datasheet. Hotarand ca este suficient pentru aceasta zi si declarandu-ma multumit pana aici, am decis ca aceasta problema are sa fie rezolvata ziua urmatoare.
   Aceasta a fost o zi mai light. Am hotarat sa testez diferite duty cycle-uri pentru a vedea cum reactioneaza servo-ul, descoperind astfel ca documentatia nu este, in tocmai, corecta ( cine ar fi crezut ). In aceasta scria ca un semnal cu o durata de 1 logic de 1 ms ( deci un duty cycle de 5% pentru un semnal de perioada de 20 ms) corespunde pozitionarii la -90 de grade fata de pozitia neutra, iar un semnal cu o durata de 1 logic de 2 ms ( duty cycle de 10% ) corespunde pozitionarii la 90 de grade fata de pozitia neutra. In urma mai multor teste, am observat ca poztiei de -90 de grade ii corespunde un semnal cu  durata de 1 logic de 0.5 ms ( duty cycle de 2.5% ), iar pozitiei de 90 de grade ii corespunde un semnal cu  durata de 1 logic de 2.5 ms ( duty cycle de 12.5% ). Pe baza acestor descoperiri, am refacut calculele si am adaptat formula de update a valorii duty cycle-ului aferent PWM-ului. Vazand ca miscarea ascestuia se realizeaza asa cum doream, am hotarat ca restul zilei sa curat codul, sa il documentez si sa iau o pauza, cum in urmatoarele zile aveam sa incep lucrul la motoarele ce actioneaza senilele, task ce stiam ca va fi ingreunat de necesitatea implementarii unei bucle de reglare pentru controlul motoarelor. Din fericire, cunsotintele de Semnale si sisteme, Teoria Sistemelor Automate si Ingineria Reglarii Automate cumulate de-a lungul licentei ( alaturi de subiectele tangente domeniului reglarii automate ) s-au dovedit foarte utile pentru implementarea acestei bucle de reglare utilizand un regulator PID.
   
-> Zilele 6-8 ( DC motor arc ):

   Motoarele de curent continuu au reprezentat pe departe cea mai laborioasa parte a procesului de development. Nu voi mai intra in detalii aici, acest proces fiind detaliat in propriul sau fisier, intitulat ( foarte sugestiv ) "Motor - masurare, identificare, reglare". Acest fisier cuprinde procesul de masurare a caracteristicilor electrice si mecanice ale motorului, precum si a corespondentei dintre acestea; identificarea functiei de transfer asociata procesului reprezentat de motor; proiectarea unui regulator pentru realizarea buclei de reglare utilizate in mentinerea turatiei motorului la o referinta setata cand acesta se afla sub sarcina; discretizarea respectivului regulator pentru a face posibila implementarea sa software. Pe departe cel mai muncitoresc proces din cadrul acestui proiect, necesitand un intreg program separat utilizat la testarea motorului, pentru ca, in final, in programul principal sa fie adaugata implementarea unei ecuatii cu diferene ce a ocupat, in total, mai putin de 20 de randuri, insa fara doar si poate cea mai placuta parte a procesului de dezvoltare al acestui proiect, necesitand aptitudini de electrotehnica, mecanica, programare si teorie a sistemelor pentru a putea fi realizata, oportunitatea de a pune in aplicare cunostintele acumulate pana acum atat pe parcursul facultatii, precum si in research-ul personal fiind foarte bine-venita. In alte cuvinte, s-a simtit foarte bine sa pun in aplicare teoria, am simtit din plin payoff-ul acestor 3 ani ( lungi ) de facultate.

-> Zilele 9-10 ( hardware arc ):

   Aceste doua zile au fost rezervate pentru partea hardware a proiectului. 
   Am inceput cu alimentarea cu energie, ajustand doua buck-convertere conectate fiecare la cate o baterie de 9V pentru alimentarea partii de comanda ( setat la 5V ) si a partii de putere ( setat la 7.5V ). Astfel, am putut asigura o cadere de tensiune constanta pe cele doua instalatii, atata timp cat caderile de tensiune pe cele doua baterii se mentineau la un nivel superior tensiunilor de iesire setate de buck-convertere. 
   Am continuat cu implmenetarea hardware a doua doua placi custom. O placa destinata expansiunii porturilor de alimentare ale partii de comanda, ce contine 3 randuri a cate 9 pini fiecare: GND, 3.3V si respectiv 5V. Intre randurile de 3.3V si GND, precum si intre randurile de 5V si GND se regaseste un condensator electrolitic de 1 uF pentru 'curatarea' liniilor de alimnetare. Cea de-a doua placa este destinata implementarii a 3 traductoare de nivel logic de la 3.3V la 5V utilizand tranzistoare bipolare, despre care am discutat si in zilele 1-3. Intre timp am achizitionat si traductoare utilizand tranzistoare CMOS, insa acestea s-au dovedit ineficiente in cazul implmenetarii buclei de reglare, nefiind capabile sa mentina tensiunea de 0V din motive care imi sunt inca necunoscute, motoarele mergand chiar si atunci cand viteza setata era 0. Realizand testele pentru motor utilizand un traductor implementat cu tranzistoare bipolare si vazand ca acesta se comporta cum era de asteptat, am hotarat ca toate cele 3 traductoare din cadrul proiectului sa fie implementate similar pe o singura placa dedicata.
   In final, am realizat cablajele interne: in cadrul partii de comanda, partii de putere si externe: intre cele doua parti, urmand sa testez ansamblul. In urma unor ( mici :) ) corecturi la nivelul codului si la realizarea cablajelor, am constatat cu bucurie ca proiectul se comporta asa cum era de asteptat. Acum, tot ce mai ramanea de facut era construirea cadrului tancului, activitate ce avea sa implice o cantitate considerabila de LEGO.

-> Ziua 11 ( tank frame arc ):

  Nu sunt multe de spus legat de aceasta zi. In urma vizionarii catorva modele de vehicule cu senile realizate de designeri LEGO / de pasionati de LEGO, am conceput un prototip al cadrului, adaugand un touch personal pe parcursul constructiei. Dupa cateva ajustari / retusuri, varianta finala a cadrului a fost finalizata, aceasta marcand finalul procesului de development al acestui proiect. Eventuale upgrade-uri / retusuri / adaugiri vor fi adaugate in versiuni viitoare ale tancului. Multumesc pentru atentie!

   
=======
-> Inainte de a incepe proiectul:

   Detin o placuta STM32-F070RB de aproximativ un an. Am inceput sa programez pe placute cu microcontrollere utilizand un Arduino Uno in anul 2 de facultate din dorinta de a intra in domeniul roboticii, fiind un subiect ce ma interesa de ceva timp. Am considerat ca, in momentul acela aveam suficiente cunostinte de programare, electronica digitala si cunostinte de baza de electronica analogica si mecanica pentru a aborda acest domeniu. Arduino a fost un punct de plecare bun din prisma simplitatii oferite de acesta: mediul de programare era suficient de straight-forward, multitudinea de biblioteci pentru diferite periferice facea programarea usoara si permitea realizarea unor proiecte nu foarte complexe rapid si cu rata de succes mare, iar layoutul ( destul de limitat ) al placutei era foarte prietenos cu incepatorii care nu au mai lucrat cu cablaje pana in acel moment. Acestea fiind spuse, simplitatea adusa de utilizarea unui Arduino Uno a inceput sa-si prezinte curand limitarile: numarul limitat de perifierice interne ( USART, I2C, SPI, Timere ), layoutul limitat, microcontroller-ul ATmega328P pe 8 biti, precum si lipsa cunstintelor mele asupra unor notiuni precum intreruperile, adresarea directa la registrii, etc. m-au impins spre a incerca o alternativa mai putin prietenoasa cu incepatorii si ce oferea o putere de procesare mai mare si un layout mai generos, asa ca m-am indreptat catre un microcontroller pe 32 de biti. Dupa cateva cautari, m-am hotarat ca o varianta buna de inceput ar fi placuta STM32-F070RB. Stiam ca inceputul nu are sa fie atat de usor, asa ca am adunat documentatia pentru aceasta ( manualul de referinta, schematica, user guide-ul, etc. ) si m-am orientat asupra unor cursuri online ce aveau ca focus programarea pe placile de dezvoltare celor de la STM, insa care sa utilizeze un microcontroller diferit fata de cel prezent pe placuta mea ( ARM Cortex M0 ), deoarece nu doream sa reproduc 1:1 ceea ce se explica in cursul respectiv, si sa trec eu prin procesul de a ma orienta asupra docuemntatiei, de a cauta adresele registrelor, de a intelege functionalitatea codului meu, de a utiliza mediul de programare ( STM32CubeIDE ) si asa mai departe. Nu a fost un proces scurt, insa in 2-3 luni eram destul de familiar cu utilizarea intreruperilor / DMA-ului, puteam conecta, programa si utiliza periferice externe precum accelerometre, giroscoape, lcd-uri prin intermediul diferitor protocoale de comunicare ( I2C, SPI, UART ), utiliza timere in diferite moduri ( normal, IC, OC, PWM, Encoder ), cauta adresele registrelor si a le adresa, procese cu care eram estul de comfortabil dupa ce am avut ocazia de a lucra cu ele pe o perioada mai lunga de timp. Cand a venit vorba despre acest proiect, am stiut ca doresc sa utilizez aceasta placuta, deoarece, pe de-o parte, eram deja familiar cu ea, imi oferea suficiente resurse pentru aplicatia pe care doream sa o implementez si, pe deasupra, imi oferea ocazia de a ma concentra pe noile elemente ce doream sa le introduc in cadrul proiectului ( modulul de comunicare prin bluetooth, motoarele de curent continuu ce actioneaza senilele, encoderele rotative precum si buclele de reglare a turatiei motoarelor implementate cu ajutorul acestora, etc. ), provocari atat hardware, cat si software. In incheierea acestei sectiuni, doresc a mentiona ca am plecat la drum avand aceasta placuta si cunostinte asupra acesteia, reprezentand baza in jurul careia are sa se contruiasca tancul propriu-zis.

-> Zilele 1-3 ( bluetooth module arc ):
   
   Am decis sa incep lucrul la proiect cu partea cea mai importanta ( in opinia mea ), si anume comunicarea prin bluetooth. Ajungand la un magazin de componente electronice din apropierea mea, am intrebat daca detin module de comunicare prin bluetooth si, spre norocul meu, am gasit un unul cu un cip ce realiza conversia bluetooth-UART, cip ce lucreaza la nivelul logic
de 3.3V, ceea ce era ideal pentru mine, placuta STM32 lucrand tot la acest nivel logic, ceea ce insemna ca nu era necesara si procurarea unui traductor de nivel logic. Am achizitionat modulul si, in seara acestei zile, am incercat sa ma documentez asupra acestuia si sa-mi fac o idee despre cum ar decurge procesul de comunicare prin bluetooth. Aici am facut prima greseala, deoarece, in loc sa citesc direct ceea ce scria pe cip-ul de pe modul, am gasit o insemnare pe PCB-ul de care acesta era atasat pe care scria ZS-040 si, dupa o cautare rapida pe 
internet, am aflat ca aceste module sunt construite in jurul cip-ului HC-05, asa ca am incheiat ziua prin a ma documenta asupra acestuia si asupra instructiunilor de programare prin UART necesare pentru a-i seta parametri. 
   In cea de-a doua zi am decis sa incerc comunicarea cu modulul. Primul indicator ca ceva nu este in regula a venit de la faptul ca, in materialele pe care le-am citit, rata de transfer 
a datelor prin UART a modulului era declarata ca avand valoarea default de 38400 bauds, insa incercand sa comunic cu acesta la aceasta rata primeam in buffer-ul de intrare numai caractere garbage, ceea ce m-a condus spre a incerca mai multe rate de transfer. Incercand 9600 bauds, am reusit sa trimit comanda de test, AT\r\n si sa primesc un raspuns pozitiv, si anume OK\r\n. Am dat initial vina pe documentatie proasta a modulului, nu ar fi fost prima data cand ma loveam de asa ceva. Al doilea indicator ca ceva nu ar fi in regula a venit de la faptul ca aproape fiecare comanda in afara de cele de test si de reset pe care le trimiteam modulului intorceau raspunsul ERROR\r\n. Am incercat sa caut pe internet daca cineva a mai intampinat aceasta problema si daca cumva sintaxa mesajelor folosite de mine ar fi eronata. Aceasta ruta nu m-a condus nicaieri, asa ca am incercat sa verific daca omiteam o secventa din setupul modulului, atat software cat si hardware ( daca trebuia sa trimit o instructiune de start, daca trebuiau realizate actiuni asupra pinului de enable, etc. ). Neavand succes nici pe aceasta ruta, am hotarat ca nu ar strica sa pun lanterna pe cip-ul de pe modul pentru a verifica daca acesta este, intr-adevar, cip-ul HC-05 si, spre surprinderea mea, am gasit inscriprionat pe acesta codul CC2541. Dupa o cautare rapida, am aflat ca acest cip imparte multe similaritati cu HC-05, printre acestea sintaxa instructiunilor de test si de reset ( destul de unfortunate, considerand faptul ca acestea au functionat mi-a dat speranta ca sunt pe pista cea buna ), insa rata default de transfer prin UART era diferita ( primul indicator de eroare ), iar restul sintaxei intructiunilor era, de asemenea, diferita ( cel de-al doilea indicator de eroare ). Dupa putina documentare am reusit sa interoghez cip-ul ( cu raspunsuri pozitive de data aceasta ) si sa setez parametrii acestuia precum numele, pin-ul de acces la conexiunea bluetooth si rata de transfer prin UART la valorile dorite de mine. La finalul zilei doi, am reusit sa setez placuta ca un bridge de comunicare dintre terminal si modulul bluetooth ( mesajele trimise din terminal erau redirectionate de catre microcontroller catre modul si vice-versa ) pentru debug / setare de parametri, sa ma conectez la bluetooth si sa trimit cateva mesaje de test prin bluetooth ( utilizand o aplicatie mobila ce functioneaza asemenea unui terminal ), mesaje ce am constatat cu bucurie ca se regasesc in buffer-ul de intrare de la modulul bluetooth utilizand modul de debug al placutei STM32 oferit de mediul de dezvoltare al celor de la STM ), ceea ce mi-a oferit confidence-ul ca, in afara de cateva coincidente nefericite legate de cip-ul ce se afla pe modulul bluetooth, restul programarii a fost realizata corect iar conexiunea mergea asa cum era de asteptat. 
   In cea de-a treia zi, stiind ca, comunicarea cu terminalul si cu modulul de pe bluetooth functioneaza, am inceput sa planific modul in care aveam sa structurez mesajele ce vor fi transmise prin bluetooth. Deoarece mesajele transmise prin UART au lungime variabila, am hotarat sa implementez comunicarea astfel: voi primi cate un byte odata utilizand modul de intrerupere al perifericei UART, urmand ca in functia de callback apelata la revenirea in programul principal in urma terminarii interrupt service routine-ului aferent perifericei UART, voi reporni receptia pe UART pentru a astepta receptionarea unui alt byte de date si asa mai departe. Consider un mesaj terminat atunci cand intalnesc un caracter special, acest caracter fiind usor de ales in cazul receptiei de la terminal si de la modulul de bluetooth ( in modul de setup al acestuia ), toate mesajele terminandu-se cu LF ( caracterul '\n' ), ceea ce imi
permitea sa verific ultimul caracter pentru a determina daca mesajul primit este complet tot in cadrul functiei de callback pentru receptie. Acum, tot ce aveam de facut era sa aleg un
caracter cu care sa termin receptia de la modulul bluetooth ( in modul de comunicare prin bluetooth al acestuia ) pentru a sti ca, la intalnirea acestui caracter, am primit un mesaj complet. Cum urmatoarea periferica pe care o aveam la indemana si pe care doream sa o setez era un servomotor pentru miscarea turelei, controlat printr-un timer setat in modul PWM al carui duty cycle trebuia modificat pentru a face servo-ul sa se miste, am hotarat ca mesajul transmis prin bluetooth va reprezenta valoarea duty cycle-ului semnalului PWM si, in consecinta, am considerat fitting ca acest mesaj sa se termine cu caracterul '%'. Dupa implementarea acestei reguli ( utilizand un switch case - pentru viteza - in care verific utlimul caracter primit la receptie ) si vazand ca totul functioneaza asa cum am planuit, am hotarat ca este suficienta munca pentru aceasta zi, urmatoarele zile concentrandu-se pe actionarea servoului prin mesaje primite de la periferica bluetooth.

-> Zilele 4-5 ( servo turret arc ):

   Setarea miscarii servoului si-a prezentat problemele din prima secunda, realizand ca acesta functioneaza la nivelul logic de 5V ( impropriu zis nivelul logic, acesta primind la intrare un semnal analogic reprezentat de tensiunea medie a semnalului PWM, tensiune controlata de catre factorul de umplere al semnalului PWM ), iar eu nu am cumparat un traductor de nivel logic de la 3.3V la 5V ( daca era de la 5V la 3.3V ar fi fost usor, as fi folosit un simplu divizor de tensiune cu o rezistenta de 1k si una de 2k, dar de la tensiune mica la tensiune mare se complica treaba :))) ), fiind fericit ca modulul bluetooth lucreaza la 3.3V. Am considerat aceasta inconveniente drept un prilej de a fi creativ si, daca e sa fi ramas cu ceva de la electronica analogica si de la partea introductiva din electronica digitala este cum functioneaza un tranzistor ttl si cum sa implementez cea mai simpla schema posibila de poarta logica cu acesta, si anume poarta NOT utilizand un singur tranzistor NPN. Avand un surplus de tranzistoare NPN si rezistente de 1k si 10k, am hotarat sa implementez 2 porti not in cascada, prima avand rezistenta de pull-up conectata la 3.3V, iar cea de-a doua la 5V, pe intrarea primei porti NOT fiind aplicat semnalul PWM cu nivelul logic de 3.3V, obtinand astfel un traductor de nivel logic rudimentar. Nu mi-am facut griji ca aceasta schema ar fi prea lenta pentu transmiterea semnalului PWM, deoarece datasheet-ul servoului recomanda ca tensiunea analogica de la intrarea acestuia sa fie generata utilizand un semnal de 50 Hz ( perioada de 20 de ms ), semnal incet ce nu ar fi trebui sa fie afectat de diferite constante de timp aparute din cauza capacitatilor parazite din circuitul traductorului, de timpii de deschidere ai tranzistoarelor, etc. . Am inceput astfel testele utilizand semnalul PWM, observand bucuros ca sevo-ul raspunde la acesta. Este posibil ca in implementarea finala a proiectului sa optez pentru un traductor de nivel logic implementat utilizand tranzistoare CMOS, insa, pentru moment ( luand in considerare diferenta de consum de curent si viteza de comutare ), insa pe moment varianta mea DIY este o alternativa acceptabila. In incheierea acestei zile, desi aveam la dispozitie o 
functie de modificare a duty cycle-ului PWM-ului disponibila intr-o biblioteca pusa la dispozitie de mediul de dezvoltare a celor de la STM, am optat sa nu o folosesc pe aceasta deoarece schimbarea duty cycle-ului necesita modificarea unui singur registru ( CCR1 - counter register 1 al perifericei Timer 16 ), profitand de aceasta ocazie pentru a adauga niste viteza aplicatiei ( evitarea update-urilor inutile ale altor registrii prin utilizarea functiei, instructiuni redundante si timpul pierdut in function call ), utilizand adresarea directa la registru, ceea ce am si facut. In cadrul functiei de callback in care receptionez mesajul de la modulul bluetooth ( primit in urma comunicarii prin bluetooth cu telefonul, mesaj ce se termina cu caracterul '%' ), am prelucrat acest mesaj ( transformand sirul de caractere in valoare numerica si, aplicand regula de 3 simpla pe baza datelor din datasheet asupra corespondentei dintre factorul de umplere si distanta - in grade - parcursa de servo, am determinat o formula prin care pot mapa duty cycle-ul semnalului PWM primit prin bluetooth la distanta parcursa de servo ) si am modificat duty cycle-ul prin adresare directa la registru. Rezultatele nu au fost in tocmai satisfacatoare, servo-ul miscandu-se numai intr-un interval de 90 de grade in locul celui de 180 de grade mentionat de datasheet. Hotarand ca este suficient pentru aceasta zi si declarandu-ma multumit pana aici, am decis ca aceasta problema are sa fie rezolvata ziua urmatoare.
   Aceasta a fost o zi mai light. Am hotarat sa testez diferite duty cycle-uri pentru a vedea cum reactioneaza servo-ul, descoperind astfel ca documentatia nu este, in tocmai, corecta ( cine ar fi crezut ). In aceasta scria ca un semnal cu o durata de 1 logic de 1 ms ( deci un duty cycle de 5% pentru un semnal de perioada de 20 ms) corespunde pozitionarii la -90 de grade fata de pozitia neutra, iar un semnal cu o durata de 1 logic de 2 ms ( duty cycle de 10% ) corespunde pozitionarii la 90 de grade fata de pozitia neutra. In urma mai multor teste, am observat ca poztiei de -90 de grade ii corespunde un semnal cu  durata de 1 logic de 0.5 ms ( duty cycle de 2.5% ), iar pozitiei de 90 de grade ii corespunde un semnal cu  durata de 1 logic de 2.5 ms ( duty cycle de 12.5% ). Pe baza acestor descoperiri, am refacut calculele si am adaptat formula de update a valorii duty cycle-ului aferent PWM-ului. Vazand ca miscarea ascestuia se realizeaza asa cum doream, am hotarat ca restul zilei sa curat codul, sa il documentez si sa iau o pauza, cum in urmatoarele zile aveam sa incep lucrul la motoarele ce actioneaza senilele, task ce stiam ca va fi ingreunat de necesitatea implementarii unei bucle de reglare pentru controlul motoarelor. Din fericire, cunsotintele de Semnale si sisteme, Teoria Sistemelor Automate si Ingineria Reglarii Automate cumulate de-a lungul licentei ( alaturi de subiectele tangente domeniului reglarii automate ) s-au dovedit foarte utile pentru implementarea acestei bucle de reglare utilizand un regulator PID.
   
-> Zilele 6-8 ( DC motor arc ):

   Motoarele de curent continuu au reprezentat pe departe cea mai laborioasa parte a procesului de development. Nu voi mai intra in detalii aici, acest proces fiind detaliat in propriul sau fisier, intitulat ( foarte sugestiv ) "Motor - masurare, identificare, reglare". Acest fisier cuprinde procesul de masurare a caracteristicilor electrice si mecanice ale motorului, precum si a corespondentei dintre acestea; identificarea functiei de transfer asociata procesului reprezentat de motor; proiectarea unui regulator pentru realizarea buclei de reglare utilizate in mentinerea turatiei motorului la o referinta setata cand acesta se afla sub sarcina; discretizarea respectivului regulator pentru a face posibila implementarea sa software. Pe departe cel mai muncitoresc proces din cadrul acestui proiect, necesitand un intreg program separat utilizat la testarea motorului, pentru ca, in final, in programul principal sa fie adaugata implementarea unei ecuatii cu diferene ce a ocupat, in total, mai putin de 20 de randuri, insa fara doar si poate cea mai placuta parte a procesului de dezvoltare al acestui proiect, necesitand aptitudini de electrotehnica, mecanica, programare si teorie a sistemelor pentru a putea fi realizata, oportunitatea de a pune in aplicare cunostintele acumulate pana acum atat pe parcursul facultatii, precum si in research-ul personal fiind foarte bine-venita. In alte cuvinte, s-a simtit foarte bine sa pun in aplicare teoria, am simtit din plin payoff-ul acestor 3 ani ( lungi ) de facultate.

-> Zilele 9-10 ( hardware arc ):

   Aceste doua zile au fost rezervate pentru partea hardware a proiectului. 
   Am inceput cu alimentarea cu energie, ajustand doua buck-convertere conectate fiecare la cate o baterie de 9V pentru alimentarea partii de comanda ( setat la 5V ) si a partii de putere ( setat la 7.5V ). Astfel, am putut asigura o cadere de tensiune constanta pe cele doua instalatii, atata timp cat caderile de tensiune pe cele doua baterii se mentineau la un nivel superior tensiunilor de iesire setate de buck-convertere. 
   Am continuat cu implmenetarea hardware a doua doua placi custom. O placa destinata expansiunii porturilor de alimentare ale partii de comanda, ce contine 3 randuri a cate 9 pini fiecare: GND, 3.3V si respectiv 5V. Intre randurile de 3.3V si GND, precum si intre randurile de 5V si GND se regaseste un condensator electrolitic de 1 uF pentru 'curatarea' liniilor de alimnetare. Cea de-a doua placa este destinata implementarii a 3 traductoare de nivel logic de la 3.3V la 5V utilizand tranzistoare bipolare, despre care am discutat si in zilele 1-3. Intre timp am achizitionat si traductoare utilizand tranzistoare CMOS, insa acestea s-au dovedit ineficiente in cazul implmenetarii buclei de reglare, nefiind capabile sa mentina tensiunea de 0V din motive care imi sunt inca necunoscute, motoarele mergand chiar si atunci cand viteza setata era 0. Realizand testele pentru motor utilizand un traductor implementat cu tranzistoare bipolare si vazand ca acesta se comporta cum era de asteptat, am hotarat ca toate cele 3 traductoare din cadrul proiectului sa fie implementate similar pe o singura placa dedicata.
   In final, am realizat cablajele interne: in cadrul partii de comanda, partii de putere si externe: intre cele doua parti, urmand sa testez ansamblul. In urma unor ( mici :) ) corecturi la nivelul codului si la realizarea cablajelor, am constatat cu bucurie ca proiectul se comporta asa cum era de asteptat. Acum, tot ce mai ramanea de facut era construirea cadrului tancului, activitate ce avea sa implice o cantitate considerabila de LEGO.

-> Ziua 11 ( tank frame arc ):

  Nu sunt multe de spus legat de aceasta zi. In urma vizionarii catorva modele de vehicule cu senile realizate de designeri LEGO / de pasionati de LEGO, am conceput un prototip al cadrului, adaugand un touch personal pe parcursul constructiei. Dupa cateva ajustari / retusuri, varianta finala a cadrului a fost finalizata, aceasta marcand finalul procesului de development al acestui proiect. Eventuale upgrade-uri / retusuri / adaugiri vor fi adaugate in versiuni viitoare ale tancului. Multumesc pentru atentie!

   
>>>>>>> f81766b4cf5f1c354dd4042ff9771a53c057c107
